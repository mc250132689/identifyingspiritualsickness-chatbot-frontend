<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Training Data Viewer</title>
  <link rel="stylesheet" href="style.css">
  <!-- Add docx and file saver libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/7.7.0/docx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; background: #f5f5f5; padding: 20px; }
    h1 { text-align: center; }
    #controls { max-width: 800px; margin: 10px auto; display: flex; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    #training-container { max-width: 800px; margin: 20px auto; }
    .train-msg-pair { display: flex; flex-direction: column; margin-bottom: 15px; border-left: 4px solid #ccc; padding-left: 10px; background: #fff; border-radius: 10px; white-space: pre-wrap; }
    .train-user-msg, .train-bot-msg { padding: 10px 15px; border-radius: 20px; max-width: 80%; word-wrap: break-word; margin: 5px 0; white-space: pre-wrap; }
    .train-user-msg { align-self: flex-end; background-color: #d1e7ff; }
    .train-bot-msg { align-self: flex-start; background-color: #e2e2e2; }
    .train-lang { font-size: 12px; color: #555; margin-bottom: 3px; }
    button, select, input { padding: 8px 12px; font-size: 14px; }
    #search-input { flex-grow: 1; min-width: 200px; }
  </style>
</head>
<body>
  <h1>üìù Training Data Viewer</h1>

  <div id="controls">
    <input type="text" id="search-input" placeholder="Search questions or answers...">
    <select id="lang-filter">
      <option value="">All Languages</option>
      <option value="en">English (EN)</option>
      <option value="ms">Malay (MS)</option>
      <option value="ar">Arabic (AR)</option>
    </select>
    <button id="refresh-btn">Refresh Data</button>
    <button id="export-btn">Export DOCX</button>
    <button id="import-btn">Import DOCX</button>
    <input type="file" id="import-file" style="display:none" accept=".docx">
  </div>

  <div id="training-container"></div>

  <script>
    const container = document.getElementById("training-container");
    const refreshBtn = document.getElementById("refresh-btn");
    const searchInput = document.getElementById("search-input");
    const langFilter = document.getElementById("lang-filter");
    const exportBtn = document.getElementById("export-btn");
    const importBtn = document.getElementById("import-btn");
    const importFile = document.getElementById("import-file");

    const API_URL = "https://identifyingspiritualsickness-chatbot.onrender.com/get-training-data";
    const TRAIN_API_URL = "https://identifyingspiritualsickness-chatbot.onrender.com/train";
    let trainingData = [];

    // Load training data from backend
    async function loadTrainingData() {
      try {
        const res = await fetch(API_URL);
        const data = await res.json();
        trainingData = data.training_data.reverse();
        displayData(trainingData);
      } catch (err) {
        container.innerHTML = "Error loading data.";
      }
    }

    function displayData(data) {
      container.innerHTML = "";
      if (!data.length) {
        container.innerHTML = "<p>No training data found.</p>";
        return;
      }

      data.forEach(item => {
        const pair = document.createElement("div");
        pair.className = "train-msg-pair";

        const langLabel = document.createElement("div");
        langLabel.className = "train-lang";
        langLabel.textContent = `Language: ${item.lang ? item.lang.toUpperCase() : "N/A"}`;
        pair.appendChild(langLabel);

        const userMsg = document.createElement("div");
        userMsg.className = "train-user-msg";
        userMsg.textContent = item.question;

        const botMsg = document.createElement("div");
        botMsg.className = "train-bot-msg";
        botMsg.textContent = item.answer;

        pair.appendChild(userMsg);
        pair.appendChild(botMsg);
        container.appendChild(pair);
      });
    }

    function filterAndSearch() {
      let filtered = trainingData;
      const query = searchInput.value.toLowerCase();
      const lang = langFilter.value;

      if (lang) filtered = filtered.filter(item => item.lang === lang);
      if (query) filtered = filtered.filter(item =>
        item.question.toLowerCase().includes(query) || item.answer.toLowerCase().includes(query)
      );

      displayData(filtered);
    }

    searchInput.addEventListener("input", filterAndSearch);
    langFilter.addEventListener("change", filterAndSearch);
    refreshBtn.addEventListener("click", loadTrainingData);

    // Export to DOCX
    exportBtn.addEventListener("click", async () => {
      if (!trainingData.length) return alert("No data to export!");
      const { Document, Packer, Paragraph, TextRun } = docx;
      const doc = new Document();

      trainingData.forEach(item => {
        doc.addSection({
          children: [
            new Paragraph({ children: [new TextRun({ text: `Language: ${item.lang || "en"}`, bold: true })] }),
            new Paragraph({ children: [new TextRun({ text: `Question:\n${item.question}`, break: 1 })] }),
            new Paragraph({ children: [new TextRun({ text: `Answer:\n${item.answer}`, break: 1 })] }),
            new Paragraph({ text: "------------------------" })
          ]
        });
      });

      const blob = await Packer.toBlob(doc);
      saveAs(blob, "training_data.docx");
    });

    // Import DOCX
    importBtn.addEventListener("click", () => importFile.click());
    importFile.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer });
      const text = result.value;

      const entries = text.split(/[-]{5,}/).map(t => t.trim()).filter(Boolean);

      for (let entry of entries) {
        const langMatch = entry.match(/Language:\s*(.+)/i);
        const questionMatch = entry.match(/Question:\s*\n([\s\S]*?)\nAnswer:/i);
        const answerMatch = entry.match(/Answer:\s*\n([\s\S]*)/i);

        if (!questionMatch || !answerMatch) continue;

        const newItem = {
          lang: langMatch ? langMatch[1].trim() : "en",
          question: questionMatch[1].trim(),
          answer: answerMatch[1].trim()
        };

        // Merge with existing data
        const existingIndex = trainingData.findIndex(td => td.question.trim().toLowerCase() === newItem.question.toLowerCase());
        if (existingIndex >= 0) {
          trainingData[existingIndex].answer = newItem.answer;
          trainingData[existingIndex].lang = newItem.lang;
        } else {
          trainingData.unshift(newItem);
        }

        // Sync to backend
        try {
          await fetch(TRAIN_API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(newItem),
          });
        } catch (err) {
          console.error("Failed to upload:", newItem, err);
        }
      }

      displayData(trainingData);
      alert("Training data imported and merged successfully!");
    });

    // Auto-refresh every 5 seconds
    loadTrainingData();
    setInterval(loadTrainingData, 5000);
  </script>
</body>
</html>
